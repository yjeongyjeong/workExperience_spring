!SESSION 2024-03-25 09:32:50.820 -----------------------------------------------
eclipse.buildId=3.9.14.202009151354-RELEASE-e417
java.version=11.0.19
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

This is a continuation of log file C:\Users\82104\Desktop\coding\workExperience\spring\.metadata\.bak_0.log
Created Time: 2024-03-25 16:39:36.891

!ENTRY org.eclipse.jdt.ui 4 2 2024-03-25 16:39:36.892
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-03-25 16:39:36.894
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-03-25 16:39:37.727
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.spring.board.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.spring.board.HomeController;
import com.spring.board.service.boardService;
import com.spring.board.vo.BoardVo;
import com.spring.board.vo.ComCodeVo;
import com.spring.board.vo.PageVo;
import com.spring.board.vo.UserInfoVo;
import com.spring.common.CommonUtil;

@Controller
public class BoardController {

	@Autowired
	boardService boardService;

	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);

	@RequestMapping(value = "/board/boardList.do", method = RequestMethod.GET)
	public String boardList(Locale locale, Model model, PageVo pageVo, HttpSession session) throws Exception {

		List<BoardVo> boardList = new ArrayList<BoardVo>();
		List<ComCodeVo> codeList = new ArrayList<ComCodeVo>();

		int page = 1;
		int totalCnt = 0;

		if (pageVo.getPageNo() == 0) {
			pageVo.setPageNo(page);
			;
		}

		ComCodeVo codeVo = new ComCodeVo();
		codeVo.setCodeType("menu");

		totalCnt = boardService.selectBoardCnt();
		codeList = boardService.selectCodeList(codeVo);
//		System.out.println("codeList>>>>>>>>>>>" + codeList);
		/*
		 * codeList>>>>>>>>>>> [ComCodeVo [codeType=menu, codeId=a01, codeName=일반,
		 * creator=null, modifier=null], ComCodeVo [codeType=menu, codeId=a02,
		 * codeName=Q&A, creator=null, modifier=null], ComCodeVo [codeType=menu,
		 * codeId=a03, codeName=익명, creator=null, modifier=null], ComCodeVo
		 * [codeType=menu, codeId=a04, codeName=자유, creator=null, modifier=null]]
		 */

		List<String> codeIdList = new ArrayList<>();
		for (ComCodeVo comCode : codeList) {
			codeIdList.add(comCode.getCodeId());
		}
		;
		pageVo.setCodeId(codeIdList);
		boardList = boardService.SelectBoardList(pageVo);

		UserInfoVo loginUser = (UserInfoVo) session.getAttribute("loginUser");
		System.out.println("session에서 가져온 userVo >>> " + loginUser);

		model.addAttribute("boardList", boardList);
		model.addAttribute("codeList", codeList);
		model.addAttribute("totalCnt", totalCnt);
		model.addAttribute("pageNo", page);
		model.addAttribute("loginUser", loginUser);

		return "board/boardList";
	}

	@RequestMapping(value = "/board/{boardType}/{boardNum}/boardView.do", method = RequestMethod.GET)
	public String boardView(Locale locale, Model model, HttpSession session,
			@PathVariable("boardType") String boardType, @PathVariable("boardNum") int boardNum) throws Exception {

		BoardVo boardVo = new BoardVo();

		boardVo = boardService.selectBoard(boardType, boardNum);

		UserInfoVo userVo = (UserInfoVo) session.getAttribute("loginUser");

		model.addAttribute("boardType", boardType);
		model.addAttribute("boardNum", boardNum);
		model.addAttribute("board", boardVo);
		model.addAttribute("loginUser", userVo);

		return "board/boardView";
	}

	@RequestMapping(value = "/board/boardWrite.do", method = RequestMethod.GET)
	public String boardWrite(Locale locale, Model model, ComCodeVo codeVo, HttpSession session) throws Exception {

		List<ComCodeVo> codeList = new ArrayList<ComCodeVo>();

		codeVo.setCodeType("mbti");
		codeList = boardService.selectCodeList(codeVo);

		UserInfoVo loginUser = (UserInfoVo) session.getAttribute("loginUser");

		model.addAttribute("codeList", codeList);
		model.addAttribute("loginUser", loginUser);

		return "board/boardWrite";
	}

	/*
	 * @RequestMapping(value = "/board/boardWriteAction.do", method =
	 * RequestMethod.POST)
	 * 
	 * @ResponseBody // @Transactional //되나.? public String boardWriteAction(Locale
	 * locale, @RequestBody List<?> boardData) throws Exception{
	 * 
	 * System.out.println("현재 게시글 board >>>>>>>>>>>>>>>>> " + boardData.toString());
	 * System.out.println("현재 게시글 board >>>>>>>>>>>>>>>>> " + boardData.size());
	 * 
	 * HashMap<String, String> result = new HashMap<String, String>(); CommonUtil
	 * commonUtil = new CommonUtil(); int resultCnt = -1;
	 * 
	 * //class java.lang.Integer cannot be cast to class java.lang.String 발생 =>
	 * List<String>으로 해서 발생한 문제였음.. <?>로 바꿔서 진행 int divisionNum = (Integer)
	 * boardData.get(0); System.out.println("divisionNum >> " + divisionNum);
	 * 
	 * boardData.remove(0); //0번 데이터 삭제 System.out.println("삭제 후 사이즈 >> " +
	 * boardData.size());
	 * 
	 * for(int i = 0; i < (boardData.size() /divisionNum); i++) {
	 * System.out.println(boardData.get(i));
	 * 
	 * BoardVo boardVo = new BoardVo(); boardVo.setBoardTitle((String)
	 * boardData.get(2*i)); boardVo.setBoardComment((String) boardData.get(2*i+1));
	 * 
	 * System.out.println("boardVo >> " + boardVo);
	 * 
	 * resultCnt = boardService.boardInsert(boardVo); }
	 * 
	 * result.put("success", (resultCnt > 0)?"Y":"N"); String callbackMsg =
	 * commonUtil.getJsonCallBackString(" ",result);
	 * System.out.println("callbackMsg::"+callbackMsg);
	 * 
	 * return callbackMsg; }
	 */

	@RequestMapping(value = "/board/boardWriteAction.do", method = RequestMethod.POST)
	@ResponseBody
//	@Transactional //되나.?
	public String boardWriteAction(@RequestBody List<BoardVo> boardList, Locale locale) throws Exception {
//		[{boardType=a01, boardTitle=1212, boardComment=222}, {boardType=a01, boardTitle=4545, boardComment=444}]
		System.out.println("현재 게시글 board >>>>>>>>>>>>>>>>> " + boardList.toString());

		HashMap<String, String> result = new HashMap<String, String>();
		CommonUtil commonUtil = new CommonUtil();
		int resultCnt = -1;

//		java.util.LinkedHashMap cannot be cast to class com.spring.board.vo.BoardVo (java.util.LinkedHashMap
//		list로 받아오라고 했으나 받아올 떄 objectMapper.readValue()를 부르게 되고 ArrayList.class 라는 클래스 객체를 지나게 된다.
//		json에서 ArrayList라는 객체로 역직렬화 해야하는데 타입을 모르기 때문에 발생하는 오류..
//		==>해쉬맵을 사용하거나 링크드해쉬맵 혹은 객체를 직접 커스텀
//		내가 사용한 방법은 직접 어떤 클래스로 읽어와야 하는지 명시해줌
		ObjectMapper mapper = new ObjectMapper();
		String jsonBoardList = mapper.writeValueAsString(boardList);

		List<BoardVo> boardVoList = mapper.readValue(jsonBoardList, new TypeReference<List<BoardVo>>() {
		});

		// boardVo라는 객체에 전부 데이터를 담아줌(알아서 맵핑)
		for (BoardVo boardVo : boardVoList) {
			resultCnt = boardService.boardInsert(boardVo);
			System.out.println("resultCnt >> " + resultCnt);
		}

		result.put("success", (resultCnt > 0) ? "Y" : "N");
		String callbackMsg = commonUtil.getJsonCallBackString(" ", result);
		System.out.println("callbackMsg::" + callbackMsg);

		return callbackMsg;
	}

	@RequestMapping(value = "/board/boardTypesAction.do", method = RequestMethod.GET)
	@ResponseBody
	public List<ComCodeVo> boardTypesAction(Locale locale) throws Exception {

		List<ComCodeVo> codeList = new ArrayList<ComCodeVo>();
		ComCodeVo codeVo = new ComCodeVo();
		codeVo.setCodeType("menu");
		codeList = boardService.selectCodeList(codeVo);
		return codeList;
	}

//requestMapping을 클래스 위에 써서 "/board"를 공통으로 갖게 만들고 @GetMapping이나 @PostMapping을 사용해줘도 괜찮다~

	@RequestMapping(value = "/board/{boardType}/{boardNum}/boardModify.do", method = RequestMethod.GET)
	public String boardModify(Locale locale, Model model, @PathVariable("boardType") String boardType,
			@PathVariable("boardNum") int boardNum) throws Exception {

		System.out.println("========================get========================");

		System.out.println(boardType);
		System.out.println(boardNum);

		BoardVo boardVo = new BoardVo();
		boardVo = boardService.selectBoard(boardType, boardNum);
		System.out.println(boardVo.toString());

		model.addAttribute("boardType", boardType);
		model.addAttribute("boardNum", boardNum);
		model.addAttribute("board", boardVo);
		return "board/boardModify";
	}

	@RequestMapping(value = "/board/boardModifyAction.do", method = RequestMethod.POST)
	@ResponseBody
	public String boardModifyAction(Locale locale, BoardVo boardVo, Model model) throws Exception {

		System.out.println("=========================post=======================");
		System.out.println("boardVo >>> " + boardVo.toString());
		// boardType에서 null값 에러 발생.. 왜냐면 쿼리스트링에서 가져오지도 않았고 hidden으로 가져오지도 않았기 때문
		// 쿼리스트링 귀찮아서 그냥 hidden으로 가져옴

		HashMap<String, String> result = new HashMap<String, String>();
		CommonUtil commonUtil = new CommonUtil();

		int resultCnt = boardService.boardUpdate(boardVo);
		System.out.println("resultCnt >>>>>>>>>>>>>>>>>> " + resultCnt);
		// 영향받은 행의 개수이므로 양수면 성공인건가?
		result.put("success", (resultCnt > 0) ? "Y" : "N");

		String callbackMsg = commonUtil.getJsonCallBackString(" ", result);

		System.out.println("callbackMsg::" + callbackMsg);

		return callbackMsg;
	}

	@RequestMapping(value = "/board/boardRemoveAction.do", method = RequestMethod.POST)
	@ResponseBody // 없으면 json데이터를 인식못하는 것 같음...? callbackMsg 반환이 안됨
	public String boardRemove(Locale locale, BoardVo boardVo, Model model) throws Exception {

		System.out.println("boardRemoveAction~~~~~");
		System.out.println("delete 할 board >>>>>>>>>>>>>>>>>>>>>> \n" + boardVo);
//		
//		boardVo = boardService.selectBoard(boardVo.getBoardType(), boardVo.getBoardNum());
//		System.out.println("delete 할 board >>>>>>>>>>>>>>>>>>>>>> \n" + boardVo);
		System.out.println("boardType >> " + boardVo.getBoardType());
		System.out.println("boardNum >> " + boardVo.getBoardNum());

		HashMap<String, String> result = new HashMap<String, String>();
		CommonUtil commonUtil = new CommonUtil();

		int resultCnt = boardService.boardDelete(boardVo);
		System.out.println("resultCnt >>>>>>>>>>>>>>>>>> " + resultCnt);
		result.put("success", (resultCnt > 0) ? "Y" : "N");

		String callbackMsg = commonUtil.getJsonCallBackString(" ", result);

		System.out.println("callbackMsg::" + callbackMsg);
		System.out.println("삭제된 번호 >> " + boardVo.getBoardNum());

		model.addAttribute("msg", "게시글이 삭제되었습니다.");

		return callbackMsg;
	}

	@RequestMapping(value = "/board/boardSearchAction.do", method = RequestMethod.POST)
	@ResponseBody
	public List<BoardVo> boardSearchAction(@RequestBody List<String> boardList, Model model, Locale locale)
			throws Exception {
		PageVo pageVo = new PageVo();

		int page = 1;
		int totalCnt = 0;
		if (pageVo.getPageNo() == 0) {
			pageVo.setPageNo(page);
		}

		List<BoardVo> searchBoardList = new ArrayList<BoardVo>();
		// codeId로 찾음
		pageVo.setCodeId(boardList);
		searchBoardList.addAll(boardService.SelectBoardList(pageVo));

		System.out.println(searchBoardList.toString());
		return searchBoardList;
	}

	@RequestMapping(value = "/board/boardJoin.do", method = RequestMethod.GET)
	public String boardjoin(Locale locale, Model model, ComCodeVo codeVo) throws Exception {

		List<ComCodeVo> codeList = new ArrayList<ComCodeVo>();

		codeVo.setCodeType("phone");
		codeList = boardService.selectCodeList(codeVo);
		model.addAttribute("codeList", codeList);

		return "board/boardJoin";

	}

	@RequestMapping(value = "/board/boardUserIdCheckAction.do", method = RequestMethod.POST)
	@ResponseBody
	public int boardUserIdCheckAction(@RequestBody UserInfoVo userVo, Model model, Locale locale) throws Exception {
		System.out.println(">>>>>>>>>>>>>>>>>>>> " + userVo.toString()); // userId=212tt 이렇게 값이 들어옴!

		int userIdCnt = boardService.userIdCheck(userVo);
		System.out.println(">>>>>>>>>>>>>>>>>>>>" + userIdCnt);

		if (userIdCnt == 0) {
			userIdCnt = 0;
		} else {
			userIdCnt = -1;
		}

		return userIdCnt;
	}

	@RequestMapping(value = "/board/boardUserPwCheckAction.do", method = RequestMethod.POST)
	@ResponseBody
	public int boardUserPwCheckAction(@RequestBody List<String> pwList, Model model, Locale locale) throws Exception {
		// String으로 받는 경우 {"userPw":"1313","userPwChk":"1313"}
		// List<String>으로 받는 경우[{userPw=111, userPwChk=111}]
		// ajax에서 pwList에 각각 값을 담아줌 [123, 122]

		int userPwdCnt = -1;

		String userPw = pwList.get(0).toString();
		String userPwChk = pwList.get(1).toString();

		System.out.println("pwdcheck >> " + userPw + " " + userPwChk);
		if (userPw.equals(userPwChk)) {
			// userPw == userPwChk는 같은 값이여도 오류나는 걸로 봐서 주소값 비교
			// ==> 직접 문자열 비교하도록 equals 사용
			userPwdCnt = 1;
		} else {
			userPwdCnt = 0;
		}

		return userPwdCnt;
	}

	@RequestMapping(value = "/board/boardUserjoinAction.do", method = RequestMethod.POST)
	@ResponseBody
	public String boardUserjoinAction(UserInfoVo userVo, Model model, Locale locale) throws Exception {

//		ObjectMapper mapper = new ObjectMapper();
//		String jsonUserInfoList = mapper.writeValueAsString(userList);
//
//		List<UserInfoVo> userInfoList = mapper.readValue(jsonUserInfoList, new TypeReference<List<UserInfoVo>>() {
//		});

		System.out.println(">>>>>>>>>>>>>>>>>>>> " + userVo); // 주소값나옴...

		HashMap<String, String> result = new HashMap<String, String>();
		CommonUtil commonUtil = new CommonUtil();

		int resultCnt = boardService.userInsert(userVo);
		// ORA-00947: not enough values 발생!
		// userAddr2랑 userCompany에 값을 입력하지 않으면 그대로 null이 되어서 들어가지 않음...
		// 음.. 새로 userVo를 만들고 넣어야하는걸까?-> jsp에서 하려고했는데 if조건으로 하는

		System.out.println("resultCnt >>>>>>>>>>>>>>>>>> " + resultCnt);
		result.put("success", (resultCnt > 0) ? "Y" : "N");

		String callbackMsg = commonUtil.getJsonCallBackString(" ", result);

		System.out.println("callbackMsg::" + callbackMsg);

		return callbackMsg;
	}

	@RequestMapping(value = "/board/boardLogin.do", method = RequestMethod.GET)
	public String boardLogin(Locale locale, Model model) throws Exception {

		return "board/boardLogin";
	}

	@RequestMapping(value = "/board/boardUserLoginAction.do", method = RequestMethod.POST)
	@ResponseBody
	public UserInfoVo boardUserLoginAction(UserInfoVo userVo, HttpServletRequest request, Model model, Locale locale)
			throws Exception {

		System.out.println(">>>>>>>>>>>>>>>>>>>> " + userVo.toString()); // 주소값나옴...

		UserInfoVo loginUser = boardService.selectUser(userVo);

		if (loginUser != null) {
			HttpSession session = request.getSession();
			session.setAttribute("loginUser", loginUser); // user가 있으면 1 (count 쿼리)
			System.out.println(session.toString());
			System.out.println(session.getAttribute("loginUser"));
			// UserInfoVo [userId=whffu1, userPw=whffu1!, userName=null, userPhone1=null,
			// userPhone2=null, userPhone3=null, userAddr1=null, userAddr2=none,
			// userCompany=none, creator=null, modifier=null]
		}
		return loginUser;
	}

	@RequestMapping(value = "/board/boardUserLogoutAction.do", method = RequestMethod.POST)
	@ResponseBody
	public String boardUserLogoutAction(UserInfoVo userVo, HttpServletRequest request, Model model, Locale locale)
			throws Exception {

		System.out.println(">>>>>>>>>boardUserLogoutAction>>>>>>>>>> " + userVo.toString());

		int loginCheckNum = boardService.userLoginCheck(userVo);
		System.out.println("resultCnt >>>>>>>>>>>>>>>>>> " + loginCheckNum);

		HashMap<String, String> result = new HashMap<String, String>();
		CommonUtil commonUtil = new CommonUtil();

		result.put("success", (loginCheckNum > 0) ? "Y" : "N");

		String callbackMsg = commonUtil.getJsonCallBackString(" ", result);

		System.out.println("callbackMsg::" + callbackMsg);

		if (userVo.getUserId() != null) {
			HttpSession session = request.getSession();
			session.removeAttribute("loginUser");
			System.out.println("세션만료");
		}
		return callbackMsg;
	}

	@RequestMapping(value = "/mbti/mbtiTest.do", method = RequestMethod.GET)
	public String mbtiTest(Locale locale, Model model, PageVo pageVo) throws Exception {

		List<BoardVo> mbtiList = new ArrayList<BoardVo>();
		List<ComCodeVo> codeList = new ArrayList<ComCodeVo>();

		int page = 1;

		if (pageVo.getPageNo() == 0) {
			pageVo.setPageNo(page);
			;
		}

		ComCodeVo codeVo = new ComCodeVo();
		codeVo.setCodeType("mbti");

		codeList = boardService.selectCodeList(codeVo);

		System.out.println("codeList >>> " + codeList);

		List<String> codeIdList = new ArrayList<>();
		for (ComCodeVo comCode : codeList) {
			codeIdList.add(comCode.getCodeId());
		};

		pageVo.setCodeId(codeIdList);
		pageVo.setCodeType("mbti");
		mbtiList = boardService.SelectMbtiList(pageVo);

		model.addAttribute("mbtiList", mbtiList);
		model.addAttribute("codeList", codeList);
		model.addAttribute("pageNo", page);

		return "mbti/mbtiTest";
	}

	@RequestMapping(value = "/mbti/mbtiResultAction.do", method = RequestMethod.POST)
	@ResponseBody
	public String mbtiResultAction(@RequestBody List<String> resultList, 
			Model model, Locale locale, HttpSession session) throws Exception {
		
		List<String> mbtiResultList = new ArrayList<String>();
		List<String> myList= new ArrayList<String>();
		String mbtiCollection = "";
		int pageNumber = 0;
		
		System.out.println(">>>>>>>>>mbtiResultAction>>>>>>>>>> " + resultList.toString());
//		>>>>>>>>>mbtiResultAction>>>>>>>>>> [PJ_2_4, IE_2_4, NS_2_4, EI_2_4, TF_2_4]
		
		//매우동의~비동의는 1~7의 값을 가지고 각 123점의 점수로 계산
		Map<Integer, Integer> answerMap = new HashMap<>(); 
		answerMap.put(1, 3);
		answerMap.put(2, 2);
		answerMap.put(3, 1);
		answerMap.put(4, 0);
		answerMap.put(5, 1);
		answerMap.put(6, 2);
		answerMap.put(7, 3);

		for (int i = 0; i < resultList.size(); i++) {
			String[] splitList = resultList.get(i).split("_"); //PJ_2_4 => [PJ, 2, 4]
			String[] splitType = splitList[0].split("");
			//selectNum : [PJ, 2, 4] 마지막 숫자 => 점수를 나타냄
			int selectNum =  Integer.parseInt(splitList[2]) ;
			
			//TF 이런식으로 나왔을때 비동의하는 경우(value=> 5 6 7)
			if(selectNum > 4) { 
				mbtiCollection += splitType[1].repeat(answerMap.get(selectNum));
				System.out.println("mbtiCollection >>>> " + mbtiCollection);
			
			//동의 하는 경우(value=> 1 2 3)
			} else if(selectNum < 4){ 
				mbtiCollection += splitType[0].repeat(answerMap.get(selectNum));
				System.out.println("mbtiCollection >>>> " + mbtiCollection);
			} 
		}
		
		//결과값 저장...
		mbtiResultList.add(mbtiCollection);
		System.out.println("mbtiResultList >>>> " + mbtiResultList);
		
		//세션이 없으면 만들어서 저장
		if(session.getAttribute("mbtiResultSession") == null) {
			session.setAttribute("mbtiResultSession", mbtiResultList);
			pageNumber = 1;
		} 
		//세션이 있으면 기존값에다가 새로운 값 추가해서 저장
		else { 
			myList = (List<String>) session.getAttribute("mbtiResultSession");
			myList.addAll(mbtiResultList);
			System.out.println(myList.toString());
			pageNumber = myList.size(); //[JTIPF, PEPPF, FSESF, PISIT] 이런식으로 저장됨
			session.setAttribute("mbtiResultSession", myList);
		}

		System.out.println("pageNumberpageNumber >>>> " + pageNumber);
		
		//컨트롤러가 이렇게 길고 복잡해도 되는걸까?
		if(pageNumber < 4) {
			return String.valueOf(pageNumber+1);
		} else {// 5문항씩 4페이지 테스트가 다 끝난경우
			return myList.toString();
		}
	}

	@RequestMapping(value = "/mbti/mbtiResult.do", method = RequestMethod.GET)
	public String mbtiResult(Locale locale, Model model, HttpSession session ) throws Exception {

		if(session.getAttribute("mbtiResultSession") != null) {
			List<String> mbtiResultSession =  (List<String>) session.getAttribute("mbtiResultSession");
			
			System.out.println(mbtiResultSession.toString());
			//[JTIPF, PEPPF, FSESF, PISIT]
			
			List<String> mbtiTypeList = boardService.mbtiTypeList();
			System.out.println("mbtiTypeList>>> " + mbtiTypeList + "mbtiTypeList size>>> " + mbtiTypeList.size());
			//mbtiTypeList>>> [E, F, I, J, N, P, S, T] size 8개! : 알파벳순이다..
			
	        Map<String, Integer> resultMap = new HashMap(); 
			for(int i = 0; i < mbtiTypeList.size(); i++ ) {
				
		        String target = mbtiTypeList.get(i); // 찾을 문자
		
		        // 정규 표현식 패턴 생성
		        String regex = String.valueOf(target);
		        Pattern pattern = Pattern.compile(regex);
		
		        // Matcher를 사용하여 일치하는 부분 찾기
		        Matcher matcher = pattern.matcher(mbtiResultSession.toString());
		        int count = 0;
		        while (matcher.find()) {
		            count++;
		        }
		
		        //"E", 3 이런식으로 값을 저장
		        resultMap.put(mbtiTypeList.get(i), count); 
		        System.out.println("문자 '" +mbtiTypeList.get(i) + "'의 개수: " + count);
			}
			
			//2차원 배열에 값을 저장함.....
			char[][] mbtiResultList = {
			    {'E', 'I'},
			    {'N', 'S'},
			    {'T', 'F'},
			    {'P', 'J'}
			};

			//두값비교해서 정렬하는 식으로 진행함...
			for(int i = 0; i < 4; i++) {
				for(int j = 0; j < 1 ; j++) {
					//{'P', 'J'} 같은 경우 둘이 순서를 바꿈(알파벳순으로)
					if(mbtiResultList[i][j] >= mbtiResultList[i][j+1] ) {
						char temp = mbtiResultList[i][j];
						mbtiResultList[i][j] = mbtiResultList[i][j+1];
						mbtiResultList[i][j+1] = temp;
					}
				}
			}
	
			String mbtiResult = "";

			// 정렬된 순서대로 값을 가져와서 결과 문자열에 추가함
			for(int i = 0; i < 4; i++) {
				for(int j = 0; j < 1 ; j++) {
					//알파벳 별 개수비교
					if(resultMap.get(String.valueOf(mbtiResultList[i][j])) > resultMap.get(String.valueOf(mbtiResultList[i][j+1])) ) {
						mbtiResult += String.valueOf(mbtiResultList[i][j]);
					}
					else if(resultMap.get(String.valueOf(mbtiResultList[i][j])) == resultMap.get(String.valueOf(mbtiResultList[i][j+1]))) {
						int a = mbtiResultList[i][j];
						int b = mbtiResultList[i][j+1];
						(a > b) ?( mbtiResult += mbtiResultList[i][j] : mbtiResult += mbtiResultList[i][j] ;
					}
					else {
						mbtiResult += String.valueOf(mbtiResultList[i][j+1]);
					}
				}
			}

			System.out.println("result =============> " + mbtiResult);

			model.addAttribute("mbtiResult", mbtiResult);
			session.removeAttribute("mbtiResultSession");
			
			return "mbti/mbtiResult";
		
		}//end if(session != null)
	
		else { //session == null
			model.addAttribute("mbtiResult" , "");
			return "mbti/mbtiResult";
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-03-25 16:39:37.729
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-03-25 16:39:37.731
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-03-26 09:31:42.952 -----------------------------------------------
eclipse.buildId=3.9.14.202009151354-RELEASE-e417
java.version=11.0.19
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.ui 2 0 2024-03-26 09:33:17.994
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.994
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.995
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.996
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2024-03-26 09:33:17.997
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2024-03-26 09:33:20.727
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-03-26 09:33:20.727
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44f5259a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e871e93,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.wst.html.ui 1 1 2024-03-26 09:34:01.240
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT

!ENTRY org.eclipse.wst.html.ui 1 1 2024-03-26 09:34:01.247
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT

!ENTRY org.eclipse.wst.html.ui 1 1 2024-03-26 09:34:01.263
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT

!ENTRY org.eclipse.egit.ui 2 0 2024-03-26 09:34:07.924
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\82104'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
